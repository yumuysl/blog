import{_ as l}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as i,f as o,o as s}from"./app-Cze3y6Uo.js";const d={};function c(t,e){return s(),i("div",null,[...e[0]||(e[0]=[o(`<h2 id="react全栈框架-next-js" tabindex="-1"><a class="header-anchor" href="#react全栈框架-next-js"><span>react全栈框架：next.js</span></a></h2><h4 id="思维导图" tabindex="-1"><a class="header-anchor" href="#思维导图"><span>思维导图</span></a></h4><ul><li>待补充</li></ul><h4 id="安装" tabindex="-1"><a class="header-anchor" href="#安装"><span>安装</span></a></h4><div class="language-shell line-numbers-mode" data-highlighter="shiki" data-ext="shell" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-shell"><span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">npx</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> create-next-app@latest</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><h4 id="项目文件结构-记录部分入门常用" tabindex="-1"><a class="header-anchor" href="#项目文件结构-记录部分入门常用"><span>项目文件结构(记录部分入门常用)</span></a></h4><ol><li>顶层文件夹</li></ol><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-"><span class="line"><span>app：应用路由（推荐）</span></span>
<span class="line"><span>pages：页面路由</span></span>
<span class="line"><span>public: 提供的静态资源</span></span>
<span class="line"><span>src: 可选的应用源文件夹</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="2"><li>顶层文件</li></ol><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-"><span class="line"><span>next.config.js  ----	Next.js 的配置文件</span></span>
<span class="line"><span>package.json    ----  项目依赖和脚本</span></span>
<span class="line"><span>middleware.ts   ---- Next.js请求中间件</span></span>
<span class="line"><span>.env            ---- 环境变量</span></span>
<span class="line"><span>.env.local      ---- 本地环境变量</span></span>
<span class="line"><span>.env.production ---- 生产环境变量</span></span>
<span class="line"><span>.eslintrc.json  ---- ESLint 的配置文件</span></span>
<span class="line"><span>.gitignore      ---- 要忽略的 Git 文件和文件夹</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>其他的查看官网</p><ol start="3"><li>Next.Cli相关命令 <ul><li><code>npx next build</code>或者<code>pnpm next build</code><ul><li>构建时会输出每条路由的信息，比如 Size 和 First Load JS。注意这些值指的都是 gzip 压缩后的大小。其中 First Load JS 会用绿色、黄色、红色表示，绿色表示高性能，黄色或红色表示需要优化。<code>加载目标路由一共所需的 JS 大小 = 每个路由都需要依赖的 JS 大小 + 目标路由单独依赖的 JS 大小</code><ul><li>next.js项目中，页面表现类似单页面，路由跳转时不会刷新页面，会加载目标路由所需要的资源然后展示。</li><li>Size 和 First Load JS的含义：加载目标路由一共所需的 JS 大小就是 First Load JS；目标路由单独依赖的 JS 大小就是 Size；每个路由都需要依赖的 JS 大小就是图中单独列出来的 First load JS shared by all</li></ul></li><li><code>next build --profile</code>：该命令参数用于开启React的生产性能分析，可以结合react浏览器插件和 React 的 Profiler API检查线上bug</li><li><code>next build --debug</code>：该命令参数用于开启更详细的构建输出，比如rewrites、redirects、headers。</li></ul></li><li><code>next dev</code>：开发模式运行应用，会自动开启热加载、错误报告等功能，默认情况下使用的端口号为3000，如果需要更改端口号：<code>npx next dev -p 4000</code>，如果需要更改主机名（以便其他主机访问）：<code>npx next dev -H 192.168.1.2</code></li><li><code>next start</code>：生产模式下，使用 next start运行程序。不过要先执行 next build构rtt建出生产代码。运行的时候，跟开发模式相同。</li><li><code>next lint</code>：会为 pages/、app/、components/、lib/、src/目录下的所有文件执行 ESLint 语法检查。如果你没有安装 ESLint，该命令会提供一个安装指导。如果你想要指定检查的目录：<code>npx next lint --dir [文件夹名称]</code></li><li><code>next info</code>：打印当前系统相关的信息，可用于报告bug，打印的信息可以贴到issue中方便官方人员排查问题</li></ul></li></ol><h4 id="页面和路由-只记录应用路由" tabindex="-1"><a class="header-anchor" href="#页面和路由-只记录应用路由"><span>页面和路由(只记录应用路由)</span></a></h4><div style="background:rgb(200,200,100), font-size: 25px;"> 为什么需要替换页面路由：原因之一是页面路由存在一个弊端，那就是pages 目录的所有 js 文件都会被当成路由文件，这就导致比如组件不能写在 pages 目录下，这就不符合开发者的使用习惯。 </div><ol><li>app路由约定 <ul><li>每个页面就是组件，可以导入其他页面或者被导入</li><li>含有<code>page.js</code>的文件夹（即路由段）就是页面，每个文件夹下的<code>page.js</code>用于页面编辑并且暴露给给外界导航访问，如果没有<code>page.js</code>而是其他<code>js / jsx </code>文件，则外界不能访问但可以在其他页面导入使用</li><li><code>layout.js</code>文件是每个页面的布局文件，如果没有则使用父级的<code>layout.js</code>内的布局，同一文件夹下如果有 <code>layout.js</code> 和 <code>page.js</code>，page 会作为 children 参数传入 layout。换句话说，layout 会包裹同层级的 page。同时对于<code>app/layout.js</code>作为根路由，以下是必须的： <ul><li>app 目录必须包含根布局，也就是 app/layout.js 这个文件是必需的。</li><li>根布局必须包含 html 和 body标签，其他布局不能包含这些标签。如果你要更改这些标签，不推- 荐直接修改，参考《Metadata 篇》。</li><li>你可以使用路由组创建多个根布局。</li></ul></li><li>默认根布局是服务端组件，且不能设置为客户端组件。</li><li>嵌套路由：<code>folder/folder</code></li><li>动态路由：<code>[folder]</code>、<code>[...folder]</code>、<code>[[...folder]]</code></li><li>定义模板：模板类似于布局，但不会像布局那样维持状态</li><li>在app目录新建一个<code>template.js</code>文件，用法与布局一模一样，但如果同一目录下既有模板又有布局，layout会包裹template，template又会包裹pape</li><li>定义加载界面：App Router提供了用于展示加载界面的loading.js，在页面加载完成前显示的界面，这个功能的实现借助了 React 的Suspense API</li><li>定义错误处理：<code>error.js</code>，用来创建发生错误时展示的ui，其实现借助了 React 的 Error Boundary 功能。</li><li>简单来说，就是给 page.js 和 children 包了一层 ErrorBoundary。</li><li>另外，因为 Layout 和 Template 在 ErrorBoundary 外面，这说明错误边界不能捕获同级的 layout.js 或者 template.js 中的错误。如果你想捕获特定布局或者模板中的错误，那就需要在父级的 error.js 里进行捕获。</li><li>如何捕获根布局的错误？<code>next.js</code>提供了一个<code>global-error.js</code>文件，需要放入app目录，<code>global-error.js</code>会包裹整个应用，而且当它触发的时候，它会替换掉根布局的内容。所以，<code>global-error.js</code> 中也要定义 <code>&lt;html&gt;</code> 和 <code>&lt;body&gt;</code> 标签。</li><li>定义404页面：<code>not-found.js</code>文件，当该路由不存在的时候展示的内容，触发条件有两类，a.当组件抛出了notFound 函数的时候; b.当路由地址不匹配的时候</li><li>特殊文件嵌套关系： <img src="https://notesreord.oss-cn-beijing.aliyuncs.com/code/next_路由-特殊页面嵌套关系.png?x-oss-code-xxx" alt="页面加载嵌套关系" loading="lazy"></li></ul></li><li>路由导航： <ul><li>有四种方式实现路由导航：<code>&lt;Link&gt;</code>组件、使用useRouter Hook（客户端组件）、使用redirect函数（服务端组件）、使用浏览器原生History API</li><li><code>Link</code>：<code>&lt;Link href=&quot;/dashboard&quot;&gt;Dashboard&lt;/Link&gt;</code><ul><li>支持动态渲染：href中传入路由参数</li><li>链接激活检查：<code>usePathname()</code>获取当前路径是否与链接匹配<code>href</code>，但要注意添加<code>use client</code>，即只客户端使用</li><li>设置跳转行为：App Router 的默认行为是滚动到新路由的顶部，或者在前进后退导航时维持之前的滚动距离。如果需要更改，可以给 <code>&lt;Link&gt;</code> 组件传递一个 <code>scroll={false}</code>属性，或者在使用 <code>router.push</code>和 <code>router.replace</code>的时候，设置 <code>scroll: false</code>。</li></ul></li><li>redirect函数：客户端组件使用 useRouter hook，服务端组件则可以直接使用 redirect 函数，这也是 Next.js 提供的 API</li><li>History API：使用浏览器原生的 window.history.pushState 和 window.history.replaceState 方法更新浏览器的历史记录堆栈。通常与 usePathname（获取路径名的 hook） 和 useSearchParams（获取页面参数的 hook） 一起使用。</li></ul></li><li>动态路由、路由组、平行路由和拦截路由 <ul><li>动态路由：<code>/blog/[slug]</code>，<code>[slug]</code> 是动态路由的占位符，<code>slug</code><ul><li>新建文件夹，命名为<code>[slug]</code>，这里<code>slug</code>会作为路由参数<code>parms</code>传给页面</li><li>如果给前面加上省略号，即<code>[...slug]</code>，表示捕获所有后面路由片段</li><li>如果在加一个双方括号，即<code>[[...slug]]</code>，表示可选的捕获所有后面路由片段，这种方式会会匹配不带参数的路由</li></ul></li><li>路由组 <ul><li>作用：将路由和项目文件按照逻辑分组，不会影响url路径结构，标记为路由组后，会阻止该文件夹名称被映射到URL中</li><li>如何标记为路由组：把文件夹用括号括住，比如<code>(dashboard)</code></li><li>创建不同布局：在不同分组下可以创建属于这个分组的布局，最终效果是父级布局和该布局叠加起效</li><li>创建根布局：删除<code>app/layout.js</code>文件，然后在每组都创建一个 layout.js文件。创建的时候要注意，因为是根布局，所以要有 <code>&lt;html&gt;</code> 和 <code>&lt;body&gt;</code> 标签。创建多个根布局，<code>not-found.js</code>会报编译错误，这是找不到顶级<code>layout.js</code>文件引起的，可以分别为每个分组添加<code>not-found.js</code>文件，也可以新建一个路由组处理404页面 <ul><li>实用场景：比如你将前台购买页面和后台管理页面都放在一个项目里，一个 C 端，一个 B 端，两个项目的布局肯定不一样，借助路由组，就可以轻松实现区分。</li></ul></li><li>注意事项：<strong>a.</strong> 分组内创建路由时注意是否与其他分组内路由冲突 <strong>b.</strong> 创建多个根布局时，因删除了<code>app/layout.js</code>文件，访问<code>/</code>会报错，需要将<code>app/page.js</code>放入其中一个路由组中 <strong>c.</strong> 跨根布局会导致页面重新加载</li></ul></li><li>平行路由 <ul><li>作用：可以在同一布局中同时或者有条件的渲染一个或者多个页面，类似vue插槽功能</li><li>如果标记：将文件夹以<code>@</code>作为开头进行命名</li><li>实用场景举例： <ul><li>条件渲染：在布局中获取用户的登录状态，如果登录，显示 dashboard 页面，没有登录，显示 login 页面。这样做的一大好处就在于代码完全分离。</li><li>独立路由处理：平行路由可以让你为每个路由定义独立的错误处理和加载界面</li><li>子导航：平行路由也是文件夹，内部可以添加文件夹作为子导航</li></ul></li></ul></li><li>路由拦截 <ul><li>实现效果：点击导航时进行拦截处理操作，而直接获取该地址在浏览器打开则没有拦截处理</li><li>实现方式：<code>(.)</code>表示匹配同一层级；<code>(..)</code>表示匹配上一层级；<code>(..)(..)</code>表示匹配上上层级；<code>(...)</code>表示匹配根目录，注意这个匹配的是路由的层级而不是文件夹路径的层级</li></ul></li></ul></li><li>路由处理程序 <ul><li>理解：前后端分离项目中，前端和后端交互用API，这个api在Next.js中有个正式称呼，即路由处理程序</li><li>定义一个路由处理程序：在app目录下，定义一个名为<code>route.js</code>的文件，需要注意和<code>page.js</code>不能在同一级</li><li>可以在app目录中添加一个api文件夹，所有接口都写入这个文件夹中，表示通过路由处理程序获取数据</li><li><code>Next.js</code> 支持 <code>GET</code>、<code>POST</code>、<code>PUT</code>、<code>PATCH</code>、<code>DELETE</code>、<code>HEAD</code> 和 <code>OPTIONS</code> 这些 HTTP 请求方法。如果传入了不支持的请求方法，<code>Next.js</code> 会返回 <code>405 Method Not Allowed</code></li><li>请求参数：每个请求方法的处理函数会被传入两个参数，一个 request，一个 context 。两个参数都是可选的</li></ul></li><li>中间件 <ul><li>作用：可以基于传入的请求，重写、重定向、修改请求或响应头、甚至直接响应内容。一个比较常见的应用就是鉴权，在打开页面渲染具体的内容前，先判断用户是否登录，如果未登录，则跳转到登录页面。</li><li>如何定义：和pages或者app同级的目录（根目录）新建<code>middleware.js</code>文件</li><li>设置匹配路径：matcher配置项和条件语句</li><li>中间件逻辑： <ul><li>读取和设置cookies：用法跟路由处理程序一致，使用 NextRequest 和 NextResponse 快捷读取和设置 cookies</li><li>设置headers：用法跟路由处理程序一致，使用 NextRequest 和 NextResponse 快捷读取和设置 headers。</li><li>很多地方都可以设置路由的响应，执行顺序是：<code>headers（next.config.js）</code> -&gt; <code>redirects（next.config.js）</code> -&gt; <code>中间件 (rewrites, redirects 等)</code> -&gt; <code>beforeFiles (next.config.js中的rewrites)</code> -&gt; <code>基于文件系统的路由 (public/, _next/static/, pages/, app/ 等)</code> -&gt; <code>afterFiles (next.config.js中的rewrites)</code> -&gt; <code>动态路由 (/blog/[slug])</code> -&gt; <code>fallback中的 (next.config.js中的rewrites)</code></li></ul></li></ul></li></ol><h4 id="渲染" tabindex="-1"><a class="header-anchor" href="#渲染"><span>渲染</span></a></h4><ol><li>渲染-CSR、SSR、SSG、ISP <ul><li>CSR：客户端渲染，页面中使用<code>use Effect</code>hook而不是服务端的渲染方法，如<code>getStaticProps</code>和<code>getServerSideProps</code></li><li>SSR：服务端渲染，比如打开一篇博客文章页面，没有必要每次都让客户端请求，万一客户端网速不好呢，那干脆由服务端直接请求接口、获取数据，然后渲染成静态的 HTML 文件返回给用户。 <ul><li>这时HTML 是没有交互性的，客户端渲染出 HTML 后，还要等待 JavaScript 完全下载并执行。JavaScript 会赋予 HTML 交互性，这个阶段被称为水合（Hydration）。此时内容变为可交互的。</li><li>从这个过程中，我们可以看出 SSR 的几个缺点： <ul><li>SSR 的数据获取必须在组件渲染之前</li><li>组件的 JavaScript 必须先加载到客户端，才能开始水合</li><li>所有组件必须先水合，然后才能跟其中任意一个组件交互</li></ul></li></ul></li><li>SSG：静态站点生成，SSG 会在构建阶段，就将页面编译为静态的 HTML 文件，所以能用SSG就用SSG，“在用户访问之前是否能预渲染出来？”如果能，就用 SSG。</li><li>ISR：增量静态再生，比如博客文章内容也许是不变的，但点赞、收藏等数据会变，这时可能用CSR或者SSR，考虑到此场景，Next.js 提出了 ISR。当用户访问了这个页面，第一次依然是老的 HTML 内容，但是 Next.js 同时静态编译成新的 HTML 文件，当第二次访问或者其他用户访问的时候，就会变成新的 HTML 内容了。</li><li>RSC：React Server Components，同SSR渲染也是服务端渲染，但两者的最大区别是：SSR 是在服务端将组件渲染成 HTML 发送给客户端，而 RSC 是将组件渲染成一种特殊的格式，我们称之为 RSC Payload。这个 RSC Payload 的渲染是在服务端，但不会一开始就返回给客户端，而是在客户端请求相关组件的时候才返回给客户端，RSC Payload 会包含组件渲染后的数据和样式，客户端收到 RSC Payload 后会重建 React 树，修改页面 DOM。</li></ul></li><li>渲染-Suspense与Streaming <ul><li>为了解决SSR的缺点，react18引入了<code>&lt;Suspense&gt;</code>组件</li><li><code>&lt;Suspense&gt;</code> 允许你推迟渲染某些内容，直到满足某些条件（例如数据加载完毕）</li></ul></li><li>渲染-客户端组件和服务端组件 <ul><li>客户端组件：需要添加<code>use client</code>声明，可以使用<code>useEfefect</code>、<code>useState</code>等react API，也可以处理浏览器事件 <ul><li>注意：&quot;use client&quot;用于声明服务端和客户端组件模块之间的边界。当你在文件中定义了一个 &quot;use client&quot;，导入的其他模块包括子组件，都会被视为客户端 bundle 的一部分。</li></ul></li><li>服务端组件： <ul><li>优势：数据获取更快，通过减少请求数量提高性能；安全，在服务端保留敏感数据和逻辑，不用暴露给客户端；缓存方面服务端渲染的结果可以再后续的请求中复用；<code>bundle</code>打包大小</li><li>限制：服务端组件也有一些限制，比如不能使用 useState 管理状态，不能使用浏览器的 API 等等</li></ul></li><li>如何选择? <ul><li>服务端组件：获取数据、访问后端资源（直接）、在服务端上保留敏感信息（访问令牌、API 密钥等）、在服务端使用依赖包，从而减少客户端 JavaScript 大小</li><li>客户端组件：添加交互和事件侦听器、使用状态和生命周期、使用仅限浏览器的 API、使用依赖于状态效果或仅限浏览器的 API 的自定义 hook、使用 React 类组件</li></ul></li><li>渲染环境：服务端组件只会在服务端渲染，但客户端组件会在服务端渲染一次，然后在客户端渲染。</li><li>交替使用服务端组件和客户端组件：需要注意的是，服务端组件可以直接导入客户端组件，但客户端组件并不能导入服务端组件</li></ul></li><li>渲染-服务端渲染策略 <ul><li>解决的问题：比如开发模式(dev)下在页面中调用接口每次返回一个图片（服务端组件），在构建后发现页面中图片是静态的无法更新，这时服务端在构建时将页面预渲染为静态内容，也就是说返回的内容其实在构建时已经决定了，如何返回新图片呢？</li><li>三种服务端渲染策略：静态渲染 、动态渲染、Streaming</li><li>静态渲染：这是默认渲染策略，路由在构建时渲染，或者在重新验证后后台渲染，其结果会被缓存并且可以推送到 CDN。适用于未针对用户个性化且数据已知的情况，比如静态博客文章、产品介绍页面等。</li><li>动态渲染：路由在请求时渲染，适用于针对用户个性化或依赖请求中的信息（如 cookie、URL 参数）的情况。在渲染过程中，如果使用了动态函数（Dynamic functions）或者未缓存的数据请求（uncached data request），Next.js 就会切换为动态渲染。<strong>注意：作为开发者，无须选择静态还是动态渲染，Next.js 会自动根据使用的功能和 API 为每个路由选择最佳的渲染策略</strong><ul><li>使用动态函数：动态函数指的是获取只有在请求时才能得到信息（如 cookie、请求头、URL 参数）的函数。在 Next.js 中这些动态函数是： <ul><li><code>cookies()</code> 和 <code>headers()</code> ：获取 cookie 和 header</li><li><code>searchParams</code>：页面查询参数</li></ul></li><li>使用为缓存的数据请求：在 Next.js 中，fetch 请求的结果默认会被缓存，但你可以设置退出缓存，一旦你设置了退出缓存，就意味着使用了未缓存的数据请求（uncached data request），会导致路由进入动态渲染，如： <ul><li><code>fetch</code> 请求添加了 <code>cache: &#39;no-store&#39;</code>选项</li><li><code>fetch</code> 请求添加了 <code>revalidate: 0</code>选项</li><li><code>fetch</code> 请求在路由处理程序中并使用了 <code>POST</code> 方法</li><li>在<code>headers</code> 或 <code>cookies</code> 方法之后使用 <code>fetch</code>请求</li><li>配置了路由段选项 <code>const dynamic = &#39;force-dynamic&#39;</code></li><li>配置了路由段选项<code>fetchCache</code>，默认会跳过缓存</li><li><code>fetch</code> 请求使用了 <code>Authorization</code>或者 <code>Cookie</code>请求头，并且在组件树中其上方还有一个未缓存的请求</li></ul></li></ul></li><li>Streaming：使用 <code>loading.js</code> 或者 <code>React Suspense</code> 组件会开启 Streaming</li></ul></li></ol><h4 id="数据获取" tabindex="-1"><a class="header-anchor" href="#数据获取"><span>数据获取</span></a></h4><ol><li>数据获取、缓存与重新验证</li></ol>`,19)])])}const r=l(d,[["render",c]]),p=JSON.parse('{"path":"/notes/frontnotes/frontsum/Next.js.html","title":"Next笔记","lang":"zh-CN","frontmatter":{"title":"Next笔记","date":"2024-11-12T00:00:00.000Z","tag":"前端笔记","icon":"file","description":"Next.js学习笔记","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Next笔记\\",\\"image\\":[\\"https://notesreord.oss-cn-beijing.aliyuncs.com/code/next_%E8%B7%AF%E7%94%B1-%E7%89%B9%E6%AE%8A%E9%A1%B5%E9%9D%A2%E5%B5%8C%E5%A5%97%E5%85%B3%E7%B3%BB.png?x-oss-code-xxx\\"],\\"datePublished\\":\\"2024-11-12T00:00:00.000Z\\",\\"dateModified\\":\\"2026-01-18T15:38:57.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"禹穆穆\\"}]}"],["meta",{"property":"og:url","content":"https://bestoaloe.gitee.io/notes/frontnotes/frontsum/Next.js.html"}],["meta",{"property":"og:site_name","content":"禹穆穆"}],["meta",{"property":"og:title","content":"Next笔记"}],["meta",{"property":"og:description","content":"Next.js学习笔记"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://notesreord.oss-cn-beijing.aliyuncs.com/code/next_%E8%B7%AF%E7%94%B1-%E7%89%B9%E6%AE%8A%E9%A1%B5%E9%9D%A2%E5%B5%8C%E5%A5%97%E5%85%B3%E7%B3%BB.png?x-oss-code-xxx"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2026-01-18T15:38:57.000Z"}],["meta",{"property":"article:tag","content":"前端笔记"}],["meta",{"property":"article:published_time","content":"2024-11-12T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2026-01-18T15:38:57.000Z"}]]},"git":{"createdTime":1768750737000,"updatedTime":1768750737000,"contributors":[{"name":"yumuysl","username":"","email":"yinchuanyjw@outlook.com","commits":1}]},"readingTime":{"minutes":15.42,"words":4626},"filePathRelative":"notes/frontnotes/frontsum/Next.js.md","excerpt":""}');export{r as comp,p as data};
