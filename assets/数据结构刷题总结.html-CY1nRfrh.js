import{_ as a}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as l,f as t,o as i}from"./app-Bl3283Uh.js";const s={};function r(o,e){return i(),l("div",null,[...e[0]||(e[0]=[t('<h2 id="链表" tabindex="-1"><a class="header-anchor" href="#链表"><span>链表</span></a></h2><h3 id="通过双指针解决的问题" tabindex="-1"><a class="header-anchor" href="#通过双指针解决的问题"><span>通过双指针解决的问题</span></a></h3><ul><li>链表倒数第K个位置的元素 <ul><li>解决方法：P、Q指针均指向头节点，P先走K步，然后P、Q一起走，当P走到末尾时，Q就是倒数第K个位置的元素</li></ul></li><li>链表中间位置 <ul><li>解决方法：快慢指针，快指针移速是慢指针移速的二倍</li></ul></li><li>链表是否有环 <ul><li>解决方法：快慢指针，当链表中有环时，变成追击问题，当快指针与慢指针相遇时说明有环</li></ul></li><li>链表环的长度 <ul><li>解决方法：基于上述问题3，当快慢指针相遇一次后计数，当相遇两次后就是环的长度，需要注意是否需要除以2</li></ul></li></ul><h3 id="单链表" tabindex="-1"><a class="header-anchor" href="#单链表"><span>单链表</span></a></h3><ul><li>对于链表问题，返回结果为头结点时，通常需要先初始化一个预先指针 pre，该指针的下一个节点指向真正的头结点head。使用预先指针的目的在于链表初始化时无可用节点值，而且链表构造过程需要指针移动，进而会导致头指针丢失，无法返回结果。</li></ul>',5)])])}const d=a(s,[["render",r]]),u=JSON.parse('{"path":"/notes/codecourse/datastru/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%93.html","title":"数据结构刷题总结","lang":"zh-CN","frontmatter":{"title":"数据结构刷题总结","date":"2025-02-03T00:00:00.000Z","tag":"数据结构","description":"数据结构刷题总结，主要包含相关解题思路、通用经验","article":false,"feed":false,"seo":false,"head":[]},"git":{"createdTime":1739065138000,"updatedTime":1739065138000,"contributors":[{"name":"bestoaloe","username":"","email":"yinchuanyjw@outlook.com","commits":1}]},"readingTime":{"minutes":1.13,"words":339},"filePathRelative":"notes/codecourse/datastru/数据结构刷题总结.md"}');export{d as comp,u as data};
