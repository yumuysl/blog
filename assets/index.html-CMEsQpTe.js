import{_ as i}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as s,f as a,e as t,r as l,o as r}from"./app-BSD5kKW6.js";const o={};function h(p,e){const n=l("Mermaid");return r(),s("div",null,[e[0]||(e[0]=a('<h1 id="os面试题" tabindex="-1"><a class="header-anchor" href="#os面试题"><span>OS面试题</span></a></h1><h2 id="进程和线程的区别是什么" tabindex="-1"><a class="header-anchor" href="#进程和线程的区别是什么"><span>进程和线程的区别是什么？</span></a></h2><ul><li>进程是操作系统资源分配的基本单位，而线程是CPU调度和执行的基本单位 <ul><li>举例：进程好比一列火车，线程是这列火车上的一节车厢 ；如果把进程比作一个独立工厂，那线程就i是这个工厂里的每条生产线</li></ul></li><li>内存共享和隔离：进程间内存独立，带来了强大的稳定性优势，一个程序（进程）崩溃了，一般不会波及其他程序。线程共享内存则带来了高效通信的可能，因为它们可以直接读写共同的变量，但这也引入了风险：一个线程的非法操作（如非法内存访问）可能会破坏整个进程的数据，导致整个程序（包括所有线程）挂掉 。同时，共享内存也意味着需要额外的同步机制（如互斥锁）来防止多个线程同时修改同一数据造成混乱（数据竞争）</li><li>资源开销：进程需要独立分配资源，开销大，线程共享进程资源，开销小</li><li>数据通信：进程通信相对复杂，需要进程间通信（IPC），如管道、消息队列、共享内存等；线程通信简单，可以直接读写共享的全局变量/内存，但需要同步机制保障安全</li></ul><h2 id="什么是死锁-产生死锁的必要条件有哪些" tabindex="-1"><a class="header-anchor" href="#什么是死锁-产生死锁的必要条件有哪些"><span>什么是死锁？产生死锁的必要条件有哪些？</span></a></h2><h3 id="什么是死锁" tabindex="-1"><a class="header-anchor" href="#什么是死锁"><span>什么是死锁</span></a></h3><ul><li>两个或多个进程（或线程）因为竞争资源而陷入了一种相互等待的僵局，若无外力干涉，谁都无法继续执行下去</li></ul><h3 id="产生死锁的必要条件" tabindex="-1"><a class="header-anchor" href="#产生死锁的必要条件"><span>产生死锁的必要条件</span></a></h3><h4 id="互斥条件" tabindex="-1"><a class="header-anchor" href="#互斥条件"><span>互斥条件</span></a></h4><ul><li>一个资源在同一时间只能被一个进程独占使用。就像一台打印机不能同时为两个人打印文件。这是保护资源正确性的基础，但也是死锁的第一个条件</li></ul><h4 id="请求与保持条件" tabindex="-1"><a class="header-anchor" href="#请求与保持条件"><span>请求与保持条件</span></a></h4><ul><li>一个进程已经持有了至少一个资源，但又提出了新的资源请求，而该新资源恰好被其他进程占用，于是当前进程进入阻塞状态，但它并不释放自己已持有的资源</li></ul><h4 id="不可剥夺条件" tabindex="-1"><a class="header-anchor" href="#不可剥夺条件"><span>不可剥夺条件</span></a></h4><ul><li>进程已获得的资源，在其使用完毕之前，不能被其他进程强行抢占，只能由该进程主动释放</li></ul><h4 id="循环等待条件" tabindex="-1"><a class="header-anchor" href="#循环等待条件"><span>循环等待条件</span></a></h4><ul><li>存在一个进程和资源的循环等待链。比如进程P1等待P2占有的资源，P2等待P3占有的资源，……，Pn又在等待P1占有的资源，形成了一个环路</li></ul><h3 id="如何处理死锁" tabindex="-1"><a class="header-anchor" href="#如何处理死锁"><span>如何处理死锁</span></a></h3><ul><li>主要思路就是打破上述四个必要条件中的至少一个​ <ul><li>在实际开发中，死锁预防，特别是通过规定统一的资源申请顺序来破坏循环等待条件，是应用最广泛且最有效的方法之一</li></ul></li></ul><h4 id="预防死锁" tabindex="-1"><a class="header-anchor" href="#预防死锁"><span>预防死锁</span></a></h4><ul><li>通过严格的规则设计，在程序运行前就破坏死锁产生的某个必要条件 <ul><li>规定所有线程必须按照统一的全局顺序申请锁，从而破坏循环等待条件​</li></ul></li></ul><h4 id="死锁避免" tabindex="-1"><a class="header-anchor" href="#死锁避免"><span>死锁避免</span></a></h4><ul><li>系统在分配资源时进行动态评估，如果发现此次分配可能导致系统进入不安全状态，就拒绝分配​ <ul><li>银行家算法：在分配资源前模拟分配后的系统状态，确保系统始终处于安全状态</li></ul></li></ul><h4 id="死锁检测与恢复" tabindex="-1"><a class="header-anchor" href="#死锁检测与恢复"><span>死锁检测与恢复</span></a></h4><ul><li>允许死锁发生，但系统会定期检测，一旦发现则采取恢复措施 <ul><li>操作系统或数据库发现死锁后，选择“牺牲”一个进程，强制终止它并释放其资源，让其他进程继续</li></ul></li></ul><h2 id="进程有哪几种基本状态-并描述状态之间的转换过程" tabindex="-1"><a class="header-anchor" href="#进程有哪几种基本状态-并描述状态之间的转换过程"><span>进程有哪几种基本状态？并描述状态之间的转换过程</span></a></h2>',24)),t(n,{code:"eJxNj99KwmAYxs93FbsB8QZCyD8HnRREZ2MHplaSTBDDgh2YJW2ptFBytWq5wEaymiRr7Ft5M3u/bzvyFppugWfvwfN73t9zUKk2Ckf5Wp3ey1KbDL4zATm4eb6xX0ttlxosnUikeNzveT+P5AsRpMJHFwsSCEqY4+k0A+aUoPeY2C3li2cslV5Rvjbx5wrRO755Ac4Y7vWgKXq2wdMZxp9L/qj7T51wXJk7ZKnMiiOGCL9trEqe0/GQtUwsXAHGra3kjv/5jaethSvydJYJZASj57gkXakWjktFlsqulZCHy6gEbm7JQA194x94aAXDGRGvyEAPFyVDV6zMgonsuTK0BeK8Rer4WoPeyxpnvIJtE9THT+oSAtcBwSJIwIbG0zkmumKl3Gm5zlJ/RN/EsA=="}),e[1]||(e[1]=a('<ul><li>Linux中查看：在Linux等实际系统中，通过 ps命令查看进程状态（STAT列），你会看到更精细的表示： <ul><li>R (Running): 正在运行或可运行（在就绪队列中）。</li><li>S (Interruptible Sleep): 可中断的睡眠状态，属于阻塞态的一种，等待特定事件。</li><li>D (Uninterruptible Sleep): 不可中断的睡眠状态，通常在进行一些关键IO操作，连kill -9信号都无法立即终止。</li><li>T (Stopped): 进程被暂停（如通过Ctrl+Z）。</li><li>Z (Zombie): 僵尸进程，指进程已终止但其退出信息还未被父进程回收</li></ul></li></ul><h2 id="简述什么是虚拟内存-以及它的作用" tabindex="-1"><a class="header-anchor" href="#简述什么是虚拟内存-以及它的作用"><span>简述什么是虚拟内存，以及它的作用</span></a></h2><h2 id="常见的进程调度算法有哪些-如fcfs-sjf-时间片轮转-优先级调度" tabindex="-1"><a class="header-anchor" href="#常见的进程调度算法有哪些-如fcfs-sjf-时间片轮转-优先级调度"><span>常见的进程调度算法有哪些？（如FCFS, SJF, 时间片轮转，优先级调度）</span></a></h2><h2 id="简述分页和分段内存管理机制的区别" tabindex="-1"><a class="header-anchor" href="#简述分页和分段内存管理机制的区别"><span>简述分页和分段内存管理机制的区别</span></a></h2><h2 id="什么是页面置换算法-常见的页面置换算法有哪些-如fifo-lru" tabindex="-1"><a class="header-anchor" href="#什么是页面置换算法-常见的页面置换算法有哪些-如fifo-lru"><span>什么是页面置换算法？常见的页面置换算法有哪些？（如FIFO, LRU）</span></a></h2><h2 id="进程间通信-ipc-的常见方式有哪些" tabindex="-1"><a class="header-anchor" href="#进程间通信-ipc-的常见方式有哪些"><span>进程间通信（IPC）的常见方式有哪些</span></a></h2><h2 id="什么是临界区和互斥-如何实现互斥" tabindex="-1"><a class="header-anchor" href="#什么是临界区和互斥-如何实现互斥"><span>什么是临界区和互斥？如何实现互斥？</span></a></h2><h2 id="什么是操作系统内核-简述微内核和单体内核的区别。" tabindex="-1"><a class="header-anchor" href="#什么是操作系统内核-简述微内核和单体内核的区别。"><span>什么是操作系统内核？简述微内核和单体内核的区别。</span></a></h2>',8))])}const u=i(o,[["render",h]]),m=JSON.parse('{"path":"/notes/codecourse/osnotes/","title":"OS面试题","lang":"zh-CN","frontmatter":{"date":"2023-06-11T00:00:00.000Z","article":false,"description":"OS面试题 进程和线程的区别是什么？ 进程是操作系统资源分配的基本单位，而线程是CPU调度和执行的基本单位 举例：进程好比一列火车，线程是这列火车上的一节车厢 ；如果把进程比作一个独立工厂，那线程就i是这个工厂里的每条生产线 内存共享和隔离：进程间内存独立，带来了强大的稳定性优势，一个程序（进程）崩溃了，一般不会波及其他程序。线程共享内存则带来了高效通...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"WebPage\\",\\"name\\":\\"OS面试题\\",\\"description\\":\\"OS面试题 进程和线程的区别是什么？ 进程是操作系统资源分配的基本单位，而线程是CPU调度和执行的基本单位 举例：进程好比一列火车，线程是这列火车上的一节车厢 ；如果把进程比作一个独立工厂，那线程就i是这个工厂里的每条生产线 内存共享和隔离：进程间内存独立，带来了强大的稳定性优势，一个程序（进程）崩溃了，一般不会波及其他程序。线程共享内存则带来了高效通...\\"}"],["meta",{"property":"og:url","content":"https://bestoaloe.gitee.io/notes/codecourse/osnotes/"}],["meta",{"property":"og:site_name","content":"禹穆穆"}],["meta",{"property":"og:title","content":"OS面试题"}],["meta",{"property":"og:description","content":"OS面试题 进程和线程的区别是什么？ 进程是操作系统资源分配的基本单位，而线程是CPU调度和执行的基本单位 举例：进程好比一列火车，线程是这列火车上的一节车厢 ；如果把进程比作一个独立工厂，那线程就i是这个工厂里的每条生产线 内存共享和隔离：进程间内存独立，带来了强大的稳定性优势，一个程序（进程）崩溃了，一般不会波及其他程序。线程共享内存则带来了高效通..."}],["meta",{"property":"og:type","content":"website"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-10-07T13:51:47.000Z"}],["meta",{"property":"article:published_time","content":"2023-06-11T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2024-10-07T13:51:47.000Z"}]]},"git":{"createdTime":1695654607000,"updatedTime":1728309107000,"contributors":[{"name":"bestoAloe","username":"","email":"286258752@qq.com","commits":17},{"name":"bestoaloe","username":"","email":"yinchuanyjw@outlook.com","commits":6}]},"readingTime":{"minutes":4.6,"words":1380},"filePathRelative":"notes/codecourse/osnotes/README.md","excerpt":"","autoDesc":true}');export{u as comp,m as data};
